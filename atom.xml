<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jschen</title>
  
  <subtitle>当时年少春衫薄</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jschen.cn/"/>
  <updated>2020-07-08T14:55:45.713Z</updated>
  <id>http://jschen.cn/</id>
  
  <author>
    <name>jschen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM调优</title>
    <link href="http://jschen.cn/posts/1653795f/"/>
    <id>http://jschen.cn/posts/1653795f/</id>
    <published>2020-07-08T01:29:00.000Z</published>
    <updated>2020-07-08T14:55:45.713Z</updated>
    
    <content type="html"><![CDATA[<p>本文为JVM基础知识的第四篇文章。本文将主要学习JVM 调优</p><a id="more"></a><h1 id="一、内存泄漏和溢出"><a href="#一、内存泄漏和溢出" class="headerlink" title="一、内存泄漏和溢出"></a>一、内存泄漏和溢出</h1><h2 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="1.内存溢出"></a>1.内存溢出</h2><p>内存溢出的原因：程序在申请内存时，没有足够的内存空间</p><p>内存溢出的几种方式：</p><ol><li>栈溢出（如死递归方法循环调用，比如A方法调用A方法，报错StackOverflowError；如不断建立线程，一个线程2M，5000个线程就i需要10G，但我内存又没有10G，就会报错OOM）</li><li>堆溢出（如堆内存为30M，但是我需要创建一个100M的对象，就产生了OOM:Java heap space；不断创建对象，产生OOM: GC overhead limit exceeded,这种情况就是垃圾回收(线程)占用了超过98%的资源，但是回收效率不足2%）</li><li>方法区溢出（在经常动态生产大量 Class 的应用中，大量jsp(jsp第一次运行时需要编译成java类)、基于osgi的应用(同一个类，被不同加载器加载时会被设置成不同的类)）</li><li>本机内存直接溢出（分配的本地内存大小超过了JVM的限制，假设设置-XX:MaxDirectMemorySize=100m，然后通过ByteBuffer分配128M的直接内存，此时就会产生OOM: Direct buffer memory）</li></ol><h2 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="2.内存泄漏"></a>2.内存泄漏</h2><p>内存泄漏的原因：程序在申请内存后，比如一个对象，你使用完后觉得它没有用了，应该被释放掉，但是它被引用或者其他情况导致GC无法回收，一直存在，一直占用这一部分空间。</p><p>内存泄漏的几种原因：</p><ol><li>长生命周期的对象持有短生命周期对象的引用（比如我将 ArrayList 设置为静态变量，那么就算我没使用到这个ArrayList，但是在程序结束之前它都不能被释放，这就造成了内存泄漏）</li><li>连接未关闭（如数据库连接、网络连接和 IO 连接等，只有连接被关闭后，垃圾回收器才会回收对应的对象）</li><li>变量作用域不合理（一个变量定义的作用范围大于其使用范围；如果没有及时地把对象设置为 null）</li><li>内部类持有外部类<br>（Java 的非静态内部类的这种创建方式，会隐式地持有外部类的引用，而且默认情况下这个引用是强引用，因此，如果内部类的生命周期长于外部类的生命周期，程序很容易就产生内存泄漏。（你认为垃圾回收器会回收掉外部类的实例，但由于内部类持有外部类的引用，导致垃圾回收器不能正常工作）<br>解决方法：你可以在内部类的内部显示持有一个外部类的软引用(或弱引用)，并通过构造方法的方式传递进来，在内部类的使用过程中，先判断一下外部类是否被回收）</li><li>Hash值改变（比如在集合中，如果修改了对象中的那些参与计算哈希值的字段，会导致无法从集合中单独删除当前对象，造成内存泄露）</li></ol><h2 id="内存泄漏和内存溢出辨析"><a href="#内存泄漏和内存溢出辨析" class="headerlink" title="内存泄漏和内存溢出辨析"></a>内存泄漏和内存溢出辨析</h2><ul><li><p>相同与不同：<br>内存溢出：实实在在的内存空间不足导致；<br>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下。</p></li><li><p>如何避免：<br>内存溢出：检查代码以及设置足够的空间<br>内存泄漏：一定是代码有问题</p></li></ul><p>往往很多情况下，内存溢出往往是内存泄漏造成的。</p><h1 id="二、了解-MAT"><a href="#二、了解-MAT" class="headerlink" title="二、了解 MAT"></a>二、了解 MAT</h1><h2 id="浅堆和深堆"><a href="#浅堆和深堆" class="headerlink" title="浅堆和深堆"></a>浅堆和深堆</h2><p>浅堆：（Shallow Heap）是指一个对象所消耗的内存。例如，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。<br>深堆 ：这个对象被GC回收后，可以真实释放的内存大小，也就是只能通过对象被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象所持有的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。<br>举例：对象A引用了C和D，对象B引用了E。那么对象A的浅堆大小只是A本身，而如果A被回收，那么C和D都会被回收(可达性分析算法)，所以A的深堆大小为 A+C+D 之和，同时由于对象E还可以通过对象B访问到，因此不在对象A的深堆范围内。</p><h1 id="三、JDK-为我们提供的工具"><a href="#三、JDK-为我们提供的工具" class="headerlink" title="三、JDK 为我们提供的工具"></a>三、JDK 为我们提供的工具</h1><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>列出当前机器上正在运行的虚拟机进程，JPS 从操作系统的临时目录上去找。<br>-q：仅仅显示进程，<br>-m：输出主函数传入的参数 .下的 hello 就是在执行程序时从命令行输入的参数<br>-l：输出应用程序主类完整 package 名称或 jar 完整名称.<br>-v: 列出 jvm 参数, -Xms20m -Xmx50m 是启动程序指定的 jvm 参数</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。<br>假设需要每 250 毫秒查询一次进程 13616 垃圾收集状况，一共查询 10 次，那命令应当是：jstat-gc 13616 250 10<br>常用参数：<br>-class (类加载器)<br>-compiler (JIT)<br>-gc (GC 堆状态)<br>-gccapacity (各区大小)<br>-gccause (最近一次 GC 统计和原因)<br>-gcnew (新区统计)<br>-gcnewcapacity (新区大小)<br>-gcold (老区统计)<br>-gcoldcapacity (老区大小)<br>-gcpermcapacity (永久区大小)<br>-gcutil (GC 统计汇总)<br>-printcompilation (HotSpot 编译统计)</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>查看和修改虚拟机的参数<br>jinfo –sysprops 可以查看由 System.getProperties()取得的参数<br>jinfo –flag 未被显式指定的参数的系统默认值<br>jinfo –flags（注意 s）显示虚拟机的参数<br>jinfo –flag +[ 参 数 ]可以增加参数，但是仅限于由java -XX:+PrintFlagsFinal –version查询出来且为 manageable 的参数<br>jinfo –flag -[参数] 可以去除参数<br>Thread.getAllStackTraces();</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalize 执行队列、Java 堆和永<br>久代的详细信息，如空间使用率、当前用的是哪种收集器等。和 jinfo 命令一样，jmap 有不少功能在 Windows 平台下都是受限的，除了生成 dump 文件的<br>-dump 选项和用于查看每个类的实例、空间占用统计的-histo 选项在所有操作系统都提供之外，其余选项都只能在 Linux/Solaris 下使用。<br>jmap -dump:live,format=b,file=heap.bin <pid><br>Sun JDK 提供 jhat（JVM Heap Analysis Tool）命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>jhat dump 文件名<br>后屏幕显示“Server is ready.”的提示后，用户在浏览器中键入 <a href="http://localhost：7000/就可以访问详情">http://localhost：7000/就可以访问详情</a><br>使用 jhat 可以在服务器上生成堆转储文件分析（一般不推荐，毕竟占用服务器的资源，比如一个文件就有 1 个 G）</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主<br>要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。<br>在代码中可以用 java.lang.Thread 类的 getAllStackTraces（）方法用于获取虚拟机中所有线程的 StackTraceElement 对象。使用这个方法可以通过简单的几行<br>代码就完成 jstack 的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>JMX（Java Management Extensions，即 Java 管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX 可以跨越一系列异构操作系统平台、<br>系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。<br>管理远程进程需要在远程程序的启动参数中增加：<br>-Djava.rmi.server.hostname=….. -Dcom.sun.management.jmxremote<br>-Dcom.sun.management.jmxremote.port=8888<br>-Dcom.sun.management.jmxremote.authenticate=false<br>-Dcom.sun.management.jmxremote.ssl=false</p><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h3><h3 id="visualvm"><a href="#visualvm" class="headerlink" title="visualvm"></a>visualvm</h3><p>插件中心地址<br><a href="https://visualvm.github.io">https://visualvm.github.io</a><br>但是注意版本问题，不同的 JDK 所带的 visualvm 是不一样的，下载插件时需要下对应的版本。<br>一般来说，这个工具是本机调试用，一般生产上来说，你一般是用不了的（除非启用远程连接）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为JVM基础知识的第四篇文章。本文将主要学习JVM 调优&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JVM相关" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="JVM" scheme="http://jschen.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>执行子程序</title>
    <link href="http://jschen.cn/posts/2beaa71e/"/>
    <id>http://jschen.cn/posts/2beaa71e/</id>
    <published>2020-07-07T13:30:00.000Z</published>
    <updated>2020-07-07T13:03:18.283Z</updated>
    
    <content type="html"><![CDATA[<p>本文为JVM基础知识的第四篇文章。本文将主要学习JVM 执行子程序</p><a id="more"></a><h1 id="一、Class-文件结构"><a href="#一、Class-文件结构" class="headerlink" title="一、Class 文件结构"></a>一、Class 文件结构</h1><p>计算机只认识 0 和 1 ，这个称之为本地机器NativeCode</p><h2 id="Jvm-的无关性"><a href="#Jvm-的无关性" class="headerlink" title="Jvm 的无关性"></a>Jvm 的无关性</h2><p>与平台无关性是建立在操作系统上，虚拟机厂商提供了许多可以运行在各种不同平台的虚拟机，它们都可以载入和执行字节码，从而实现程序的“一次编写，到处运行” 。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，也是语言无关性的基础。Java 虚拟机不和任何语言绑定（如java，jruby等语言），它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了Java 虚拟机指令集和符号表以及若干其他辅助信息。</p><h2 id="Class-类文件（了解即可）"><a href="#Class-类文件（了解即可）" class="headerlink" title="Class 类文件（了解即可）"></a>Class 类文件（了解即可）</h2><p>任何一个Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际上它并不一定以磁盘文件的形式存在。各个数据项目严格按照顺序紧凑地排列在Class 文件之中，中间没有添加任何分隔符，这使得整个Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p><ul><li>Class 文件是一组以 8 位字节为基础单位的二进制流。</li><li>类似于结构体的伪结构来存储数据</li><li>只有两种数据类型：无符号数和表</li><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1 个字节、2 个字节、4 个字节和8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class 文件本质上就是一张表。</li></ul><h2 id="Class-文件格式详解"><a href="#Class-文件格式详解" class="headerlink" title="Class 文件格式详解"></a>Class 文件格式详解</h2><p>Class 的结构不像XML 等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.jschen.cn/JVM/Subroutine/TestClass.png" alt="对应的class文件"><br><img src="http://img.jschen.cn/JVM/Subroutine/javapTestClass.png" alt="通过javap反编译后的文件"></p><p>按顺序包括下面几个：</p><h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>上图中 <em>CA FE BA BE</em> 就是魔数。<em>00 00 00 34</em> 代表JDK1.8（这里的34是十六进制）</p><p>每个Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class 文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。</p><p>紧接着魔数的4 个字节存储的是Class 文件的版本号：第 5 和第 6 个字节是次版本号（MinorVersion），第 7 和第 8 个字节是主版本号（Major Version）。</p><p>Java 的版本号是从 45 （十进制）开始的，JDK 1.1 之后的每个JDK 大版本发布主版本号向上加1 高版本的JDK 能向下兼容以前版本的Class 文件，但不能运行以后版本的Class 文件，也就是说JDK1.7的文件可以在JDK1.8上执行，但是不能在JDK1.6上执行。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与Java 中语言习惯不一样的是，这个容量计数是从1 而不是0 开始的。<br>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。<br>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final 的常量值等。<br>而符号引用则属于编译原理方面的概念，包括了下面三类常量：类和接口的全限定名（Fully Qualified Name-哪个包下的）、字段的名称和描述符（Descriptor）、方法的名称和描述符</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>用于识别一些类或者接口层次的访问信息，包括：这个Class 是类还是接口；是否定义为public 类型；是否定义为abstract 类型；如果是类的话，是否被声明为final 等</p><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p>这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java 语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object 之外，所有的Java 类都有父类，因此除了java.lang.Object 外，所有Java 类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements 语句（如果这个类本身是一个接口，则应当是extends 语句）后的接口顺序从左到右排列在接口索引集合中</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。<br>而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。<br>字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>描述了方法的定义，但是方法里的Java 代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。<br>与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>存储Class 文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code 属性表中。</p><h1 id="二、字节码指令"><a href="#二、字节码指令" class="headerlink" title="二、字节码指令"></a>二、字节码指令</h1><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。<br>由于限制了Java 虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256 条。<br>大多数的指令都包含了其操作所对应的数据类型信息。例如：iload 指令用于从局部变量表中加载int 型的数据到操作数栈中，而fload 指令加载的则是float 类型的数据。<br>大部分的指令都没有支持整数类型byte、char 和short，甚至没有任何指令支持boolean 类型。大多数对于boolean、byte、short 和char 类型数据的操作，实际上都是使用相应的int 类型作为运算类型</p><p>阅读字节码作为了解Java 虚拟机的基础技能，有需要的话可以去掌握常见指令。知道大概指令即可，不需要熟记具体指令有哪些</p><h2 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h2><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。<br>将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。<br>将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。<br>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。<br>扩充局部变量表的访问索引的指令：wide。</p><h2 id="运算或算术指令"><a href="#运算或算术指令" class="headerlink" title="运算或算术指令"></a>运算或算术指令</h2><p>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。<br>加法指令：iadd、ladd、fadd、dadd。<br>减法指令：isub、lsub、fsub、dsub。<br>乘法指令：imul、lmul、fmul、dmul 等等</p><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p>可以将两种不同的数值类型进行相互转换，Java 虚拟机直接支持以下数值类型的宽化类型转换（即小范围类型向大范围类型的安全转换）：<br>int 类型到long、float 或者double 类型。<br>long 类型到float、double 类型。<br>float 类型到double 类型。<br>处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l 和d2f。</p><h2 id="创建类实例的指令"><a href="#创建类实例的指令" class="headerlink" title="创建类实例的指令"></a>创建类实例的指令</h2><p>new。</p><h2 id="创建数组的指令"><a href="#创建数组的指令" class="headerlink" title="创建数组的指令"></a>创建数组的指令</h2><p>newarray、anewarray、multianewarray。</p><h2 id="访问字段指令"><a href="#访问字段指令" class="headerlink" title="访问字段指令"></a>访问字段指令</h2><p>getfield、putfield、getstatic、putstatic。</p><h2 id="数组存取相关指令"><a href="#数组存取相关指令" class="headerlink" title="数组存取相关指令"></a>数组存取相关指令</h2><p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。<br>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。<br>取数组长度的指令：arraylength。</p><h2 id="检查类实例类型的指令"><a href="#检查类实例类型的指令" class="headerlink" title="检查类实例类型的指令"></a>检查类实例类型的指令</h2><p>instanceof、checkcast。</p><h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作 操作数栈的指令，包括：将操作数栈的栈顶一个或两个元素出栈：pop、pop2。<br>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。<br>将栈最顶端的两个数值互换：swap。</p><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>控制转移指令可以让Java 虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC 寄存器的值。控制转移指令如下。<br>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq 和if_acmpne。<br>复合条件分支：tableswitch、lookupswitch。<br>无条件分支：goto、goto_w、jsr、jsr_w、ret。</p><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java 语言中最常见的方法分派方式。<br>invokeinterface 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。<br>invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。<br>invokestatic 指令用于调用类方法（static 方法）。<br>invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4 条调用指令的分派逻辑都固化在Java 虚拟机内部，而invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。<br>方法调用指令与数据类型无关。</p><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short 和int 类型时使用）、lreturn、freturn、dreturn 和areturn，另外还有一条return 指令供声明为void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>在Java 程序中显式抛出异常的操作（throw 语句）都由athrow 指令来实现</p><h2 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h2><p>有monitorenter 和monitorexit 两条指令来支持synchronized 关键字的语义</p><h1 id="三、虚拟机栈再认识"><a href="#三、虚拟机栈再认识" class="headerlink" title="三、虚拟机栈再认识"></a>三、虚拟机栈再认识</h1><p>整体结构以及虚拟机栈简单介绍见<a href="http://jschen.cn/posts/1f66094b">JVM整体结构</a><br>栈帧中的数据在编译后就已经确定了，写在了字节码文件的code 属性中（属性表集合）</p><p><img src="http://img.jschen.cn/JVM/Subroutine/VMStack.png" alt=""></p><h2 id="栈桢详解"><a href="#栈桢详解" class="headerlink" title="栈桢详解"></a>栈桢详解</h2><p>当前栈帧有效：一个线程的方法调用链可能会很长，这意味着虚拟机栈会被压入很多栈帧，但在线程执行的某个时间点只有位于栈顶的栈帧才是有效的，该栈帧称为“当前栈帧”，与这个栈帧相关联的方法称为“当前方法”。</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、double、long 8 种数据类型和reference ，可以使用32 位或更小的物理内存来存放。<br>对于64 位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot 空间。Java 语言中明确的（reference 类型则可能是32 位也可能是64 位），64 位的数据类型只有long 和double 两种。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常称为操作栈，它是一个先进后出（First In Last Out,FILO）栈。同局部变量表一样， 操作数栈的每一个元素可以是任意的Java 数据类型，包括long 和double。32 位数据类型所占的栈容量为1，64 位数据类型所占的栈容量为2。<br>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在”调用其他方法的时候是通过操作数栈来进行参数传递的”。<br>java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</p><h2 id="数据重叠优化"><a href="#数据重叠优化" class="headerlink" title="数据重叠优化"></a>数据重叠优化</h2><p>虚拟机概念模型中每二个栈帧都是相互独立的，但在实际应用是我们知道一个方法调用另一个方法时，往往存在参数传递，这种做法在虚拟机实现过程中会做一些优化，具体做法如下：令两个栈帧出现一部分重叠。让下面栈帧的一部分操作数栈与上面栈帧的部分局部变量表重叠在一起，进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>既然是执行方法，那么我们需要知道当前栈帧执行的是哪个方法，栈帧中会持有一个引用（符号引用），该引用指向某个具体方法。<br>符号引用是一个地址位置的代号，在编译的时候我们是不知道某个方法在运行的时候是放到哪里的，这时我用代号com/enjoy/demo/User.Say:()V 指代某个类的方法，将来可以把符号引用转换成直接引用进行真实的调用。</p><p>用符号引用转化成直接引用的解析时机，把解析分为两大类</p><ul><li>静态解析：符号引用在类加载阶段或者第一次使用的时候就直接转换成直接引用。</li><li>动态连接：符号引用在每次运行期间转换为直接引用，即每次运行都重新转换。</li></ul><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>方法退出方式有：正常退出与异常退出<br>理论上，执行完当前栈帧的方法，需要返回到当前方法被调用的位置，所以栈帧需要记录一些信息，用来恢复上层方法的执行状态。<br>正常退出，上层方法的PC 计数器可以做为当前方法的返回地址，被保存在当前栈帧中。<br>异常退出时，返回地址是要通过异常处理器表来确定的,栈帧中一般不会保存这部分信息。<br>方法退出时会做的操作：恢复上次方法的局部变量表、操作数栈，把当前方法的返回值，压入调用者栈帧的操作数栈中，使用当前栈帧保存的返回地址调整PC 计数器的值，当前栈帧出栈，随后，执行PC 计数器指向的指令。</p><h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>虚拟机规范允许实现虚拟机时增加一些额外信息，例如与调试相关的信息。<br>一般把把动态连接、方法返回地址、其他额外信息归成一类，称为栈帧信息。</p><h1 id="四、基于栈的字节码解释执行引擎"><a href="#四、基于栈的字节码解释执行引擎" class="headerlink" title="四、基于栈的字节码解释执行引擎"></a>四、基于栈的字节码解释执行引擎</h1><p>Java 编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与基于寄存器的指令集，最典型的就是x86 的二地址指令集，说得通俗一些，就是现在我们主流PC 机中直接支持的指令集架构，这些指令依赖寄存器进行工作。</p><h2 id="基于栈的指令集"><a href="#基于栈的指令集" class="headerlink" title="基于栈的指令集"></a>基于栈的指令集</h2><p>举个最简单的例子，分别使用这两种指令集计算“1+1”的结果，基于栈的指令集会是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iconst_1 </span><br><span class="line">iconst_1 </span><br><span class="line">iadd     </span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure><p>两条iconst_1 指令连续把两个常量1 压入栈后，iadd 指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0 把栈顶的值放到局部变量表的第0 个Slot 中。</p><h2 id="基于寄存器的指令集"><a href="#基于寄存器的指令集" class="headerlink" title="基于寄存器的指令集"></a>基于寄存器的指令集</h2><p>如果基于寄存器，那程序可能会是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax，1</span><br><span class="line">add eax，1</span><br></pre></td></tr></table></figure><p>mov 指令把EAX 寄存器的值设为1，然后add 指令再把这个值加1，结果就保存在EAX 寄存器里面。<br>基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p><h1 id="五、方法调用详解"><a href="#五、方法调用详解" class="headerlink" title="五、方法调用详解"></a>五、方法调用详解</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。</p><p>在Java 语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><p>多见于方法的重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span></span>&#123; System.out.println(<span class="string">"hello,guy！"</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span></span>&#123; System.out.println(<span class="string">"hello,gentleman！"</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span></span>&#123; System.out.println(<span class="string">"hello,lady！"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">Human h1 = <span class="keyword">new</span> Man();</span><br><span class="line">Human h2 = <span class="keyword">new</span> Woman();</span><br><span class="line">StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">sr.sayHello(h1);</span><br><span class="line">sr.sayHello(h2);</span><br><span class="line"><span class="comment">//实际类型变化</span></span><br><span class="line">Human man=<span class="keyword">new</span> Man();</span><br><span class="line"><span class="comment">//静态类型变化</span></span><br><span class="line">sr.sayHello((Man)man);</span><br><span class="line">man=<span class="keyword">new</span> Woman();</span><br><span class="line">sr.sayHello((Woman)man);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义“Human”，称为变量的静态类型（Static Type），或者叫做外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><p>代码中定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标。所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello,gentleman！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello,lady！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">Human h1 = <span class="keyword">new</span> Man();</span><br><span class="line">Human h2 = <span class="keyword">new</span> Woman();</span><br><span class="line">h1.sayHello();</span><br><span class="line">h2.sayHello();</span><br><span class="line"></span><br><span class="line">h1 = <span class="keyword">new</span> Woman();</span><br><span class="line">h1.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态类型同样都是Human 的两个变量man 和woman 在调用sayHello（）方法时执行了不同的行为，并且变量man 在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同。<br>在实现上，最常用的手段就是为类在方法区中建立一个虚方法表。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p><h1 id="六、类加载机制"><a href="#六、类加载机制" class="headerlink" title="六、类加载机制"></a>六、类加载机制</h1><p><img src="http://img.jschen.cn/JVM/Subroutine/ClassLoader.png" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7 个阶段。其中验证、准备、解析3 个部分统称为连接（Linking）</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><em>初始化的5 种情况</em></p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>虚拟机规范则是严格规定了有且只有5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>遇到new、getstatic、putstatic 或invokestatic 这4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4 条指令的最常见的Java 代码场景是：使用new 关键字实例化对象的时候、读取或设置一个类的静态字段（被final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>以下为例子，可以自行运行查看是否与自己设想的结果是否一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass init！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD=<span class="string">"hello world "</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClaszz</span> <span class="keyword">extends</span> <span class="title">SuperClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"SubClass init！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果通过子类引用父类中的静态字段，只会触发父类的初始化，而不会触发子类的初始化</span></span><br><span class="line">System.out.println(SubClaszz.value);</span><br><span class="line">    <span class="comment">//使用数组的方式， 会不会打印初始化</span></span><br><span class="line"><span class="comment">//SuperClazz[]sca = new SuperClazz[10];</span></span><br><span class="line">    <span class="comment">//打印 一个常量，会不会进行初始化</span></span><br><span class="line"><span class="comment">//System.out.println(SuperClazz.HELLOWORLD);</span></span><br><span class="line">    <span class="comment">//如果使用常量去引用另外一个常量会不会进行初始化</span></span><br><span class="line"><span class="comment">//System.out.println(SuperClazz.WHAT);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li><li>数组形式的new(而不是构造方法)不会触发类初始化</li></ul><p>如果我将父类的HELLOWORLD的值改动，比如改为” hello ！”，如果没有重新编译，那么测试类打印的时候还是打印出”hello world “，因为常量是放在常量池中，每次编译时会把常量放进去，不编译是不会变动的，所以这就是为什么我们改动之后要重新编译文件的原因。</p><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>虚拟机需要完成以下 3 件事情： </p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>这是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体 上看，验证阶段大致上会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强 调一下，首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为： public static int value=123； 那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后， 存放于类构造器＜clinit＞（）方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。假设上面类变量 value 的定义变为：public static final int value=123； 编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p><h2 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h2 id="类初始化阶段"><a href="#类初始化阶段" class="headerlink" title="类初始化阶段"></a>类初始化阶段</h2><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。<br>到了初始化阶段，才真正开始执行类中定义的 Java 程序代码在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程 序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。＜clinit＞()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序 所决定的。 ＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit ＞()方法</p><p><em>初始化的单例模式（线程安全）</em><br>虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类 的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就 可能造成多个进程阻塞。所以类的初始化是线程安全的，项目中可以利用这点。</p><h1 id="七、类加载器"><a href="#七、类加载器" class="headerlink" title="七、类加载器"></a>七、类加载器</h1><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p><p>用途：热加载(如tomcat中jsp的热替换)、代码保护(通过自定义类加载器对类进行加解密)、类层次划分、OSGi等</p><h1 id="八、双亲委派模型（parents-delegate）"><a href="#八、双亲委派模型（parents-delegate）" class="headerlink" title="八、双亲委派模型（parents delegate）"></a>八、双亲委派模型（parents delegate）</h1><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。</p><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：<br>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++语言实现，是虚拟机自身的一部分；<br>另一种就是所有其他的类加载器，这些类加 载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 </p><p><img src="http://img.jschen.cn/JVM/Subroutine/ParentsDelegate.png" alt="双亲委派模型"></p><p>启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在＜JAVA_HOME＞\lib 目录中的，或者被-Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。<br>扩展类加载器（Extension ClassLoader）：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载＜JAVA_HOME＞\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<br>应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher $App-ClassLoader 实现。由于这个类加载器是ClassLoader 中的 getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance） 的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在 程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p><p><em>应用程序类加载器</em></p><p>ClassLoader 中的 loadClass 方法中的代码逻辑就是双亲委派模型： 在自定义 ClassLoader 的子类时候，我们常见的会有两种做法，一种是重写 loadClass 方法，另一种是重写 findClass 方法。其实这两种方法本质上差不多，毕竟 loadClass 也会调用 findClass，但是从逻辑上讲我们最好不要直接修改 loadClass 的内部逻辑。而是只在 findClass 里重写自定义类的加载方法。loadClass 这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass 方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p><h1 id="九、Tomcat类加载机制"><a href="#九、Tomcat类加载机制" class="headerlink" title="九、Tomcat类加载机制"></a>九、Tomcat类加载机制</h1><p>如果遵循双亲委派模型，那么但我们有两个版本的项目在tomcat中跑的时候，假设A项目调用的Customer类是1.1版本，B项目调用1.3版本，那么不就出现问题了吗，所以Tomcat并没有遵循双亲委派机制，至于它的机制是什么就等我学到Tomcat的时候再来写吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为JVM基础知识的第四篇文章。本文将主要学习JVM 执行子程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JVM相关" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="JVM" scheme="http://jschen.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM总结篇</title>
    <link href="http://jschen.cn/posts/57e6489d/"/>
    <id>http://jschen.cn/posts/57e6489d/</id>
    <published>2020-06-30T01:06:00.000Z</published>
    <updated>2020-07-07T13:03:33.399Z</updated>
    
    <content type="html"><![CDATA[<p>这是java基础知识中关于JVM的总结篇，主要为了便于查看本系列所有文章，同系列的文章都会有一篇链接汇总，便于我们学习</p><a id="more"></a><ol><li><a href="http://jschen.cn/posts/1f66094b/">(一)JVM整体结构</a>：主要学习私有区域与共享区域分别有什么东西</li><li><a href="http://jschen.cn/posts/2f70e593/">(二)虚拟机中的对象</a>：主要学习对象在虚拟机中创建和分配</li><li><a href="http://jschen.cn/posts/5f991803/">(三)垃圾回收</a>：主要学习垃圾回收算法和垃圾回收器</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是java基础知识中关于JVM的总结篇，主要为了便于查看本系列所有文章，同系列的文章都会有一篇链接汇总，便于我们学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JVM" scheme="http://jschen.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="http://jschen.cn/posts/5f991803/"/>
    <id>http://jschen.cn/posts/5f991803/</id>
    <published>2020-06-27T14:00:00.000Z</published>
    <updated>2020-07-01T02:01:38.176Z</updated>
    
    <content type="html"><![CDATA[<p>本文为JVM基础知识的第三篇文章。本文将主要学习垃圾回收算法和垃圾回收器</p><a id="more"></a><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><ol><li>java和C++等语言，最大的技术区别，就是java有自动化的垃圾回收机制（GC），这也是我们需要学习垃圾回收的意义</li><li>GC对应用的性能是有影响的</li><li>由于栈的生命周期是跟随线程的，所以一般不关注；而堆是垃圾回收关注的重点；虽然方法区也会发生GC，但效率比较低，因此也不是我们关注的重点</li></ol><h1 id="二、GC如何判断对象的存活"><a href="#二、GC如何判断对象的存活" class="headerlink" title="二、GC如何判断对象的存活"></a>二、GC如何判断对象的存活</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。（Python 在用，但主流虚拟机没有使用）<br>优点：快，方便，实现简单。<br>缺点：对象相互引用时（A.instance=B 同时 B.instance=A），很难判断对象是否该回收</p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>判定对象是否存活。<br>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<br>引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。<br><img src="http://img.jschen.cn/JVM/GC/GCRoots.png" alt=""><br>如上图，Object1至Object4都有对应的引用链到GC Roots，所以它是可达的，是存活的；而Object5至Object7则没有引用链，那么它是不可达的，是不可用的，那么就会判定它下次可以被回收。</p><p>作为 GC Roots 的对象包括下面几种：</p><ul><li>当前虚拟机栈中局部变量表中的引用的对象</li><li>当前本地方法栈中局部变量表中的引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p>注意：虽然finalize 可以完成对象的拯救，但是 JVM 不保证一定能执行，所以不能依赖finalize来进行对象拯救。</p><h1 id="三、各种引用（reference）"><a href="#三、各种引用（reference）" class="headerlink" title="三、各种引用（reference）"></a>三、各种引用（reference）</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>一般的 Object obj = new Object() ，就属于强引用。<br>（如果有 GCroots 的强引用）垃圾回收器绝对不会回收。垃圾回收器宁可抛出OOM，也不会回收。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。<br>一些有用但是并非必需，用软引用关联的对象，系统将要发生 OOM 之前，这些对象就会被回收。<br>参考代码：<br>VM 参数 -Xms10m -Xmx10m -XX:+PrintGC （设置默认大小为10M，最大也为10M，将GC结果打印出来）<br><img src="http://img.jschen.cn/JVM/GC/SoftReference.png" alt="例子"><br>运行结果:<br><img src="http://img.jschen.cn/JVM/GC/SoftReferenceResult.png" alt="打印结果"></p><p>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。但是如果每次打开图片都从磁盘文件中读取到内存再显示出来，这样虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以考虑用软引用构建缓存。 </p><h2 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用 WeakReference"></a>弱引用 WeakReference</h2><p>垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。<br>一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC 发生时，不管内存够不够，都会被回收。<br>参考代码：<br><img src="http://img.jschen.cn/JVM/GC/WeakReference.png" alt="弱引用例子"><br><img src="http://img.jschen.cn/JVM/GC/WeakReferenceResult.png" alt="弱引用打印结果"></p><p>注意：软引用 SoftReference 和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，这个缓存中的内容是可以被释放的。<br>实际运用（WeakHashMap、ThreadLocal）</p><h2 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用 PhantomReference"></a>虚引用 PhantomReference</h2><p>又称为幽灵引用，最弱，被垃圾回收的时候收到一个通知。如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动</p><h1 id="四、GC（Garbage-Collection）"><a href="#四、GC（Garbage-Collection）" class="headerlink" title="四、GC（Garbage Collection）"></a>四、GC（Garbage Collection）</h1><p>Minor GC<br>特点: 发生在新生代上，发生的较频繁，执行速度较快<br>触发条件: Eden 区空间不足\空间分配担保</p><p>Full GC<br>特点: 主要发生在老年代上（新生代也会回收），较少发生，执行速度较慢<br>触发条件:<br>调用 System.gc()<br>老年代区域空间不足<br>空间分配担保失败<br>JDK 1.7 及以前的永久代(方法区)空间不足<br>CMS GC 处理浮动垃圾时，如果新生代空间不足，则采用空间分配担保机制，如果老年代空间不足，则触发 Full GC</p><p>GC overhead limit exceeded 超过 98%的时间用来做 GC 并且回收了不到 2%的堆内存时会抛出此异常</p><ol><li>垃圾回收会占据资源</li><li>回收效率过低也会有限制</li></ol><h1 id="五、垃圾回收算法"><a href="#五、垃圾回收算法" class="headerlink" title="五、垃圾回收算法"></a>五、垃圾回收算法</h1><h2 id="1-复制算法（Copying）"><a href="#1-复制算法（Copying）" class="headerlink" title="1.复制算法（Copying）"></a>1.复制算法（Copying）</h2><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。<br>注意：内存移动是必须实打实的移动（复制），不能使用指针玩。</p><p>专门研究表明，新生代中的对象 98%是“朝生夕死”的，所以一般来说回收占据 10%的空间够用了，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor区。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。<br>这就是为什么新生代:from:to=8:1:1（80%:10%:10%）<br>HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10%的内存会被“浪费”。 </p><h2 id="2-标记-清除算法（Mark-Sweep）"><a href="#2-标记-清除算法（Mark-Sweep）" class="headerlink" title="2.标记-清除算法（Mark-Sweep）"></a>2.标记-清除算法（Mark-Sweep）</h2><p>过程:</p><ol><li>首先标记所有需要回收的对象</li><li>统一回收被标记的对象<br>缺点：</li><li>效率问题，标记和清除效率都不高</li><li>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 </li></ol><h2 id="3-标记-整理算法（Mark-Compact）"><a href="#3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.标记-整理算法（Mark-Compact）"></a>3.标记-整理算法（Mark-Compact）</h2><p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>缺点：不会产生内存碎片，但是效率相对标记-清除要低</p><h1 id="六、垃圾回收器"><a href="#六、垃圾回收器" class="headerlink" title="六、垃圾回收器"></a>六、垃圾回收器</h1><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>根据各个年代的特点选取不同的垃圾收集算法</p><ul><li>新生代使用复制算法</li><li>老年代使用标记-整理或者标记-清除算法<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。<br>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。<br>可以通过<code>jps -v</code>显示当前使用的垃圾回收器<br>请记住下图的垃圾收集器和之间的连线关系。<br><img src="http://img.jschen.cn/JVM/GC/AllCollection.png" alt="">并不是说新生代使用了Serial，那么老年代就只能使用Serial Old，它也可以使用CMS，是可以自由组合的，上面的连线就代表这可以使用</li></ul><p><em>各种垃圾回收器</em></p><table>    <tr>        <th>新生代</th>        <th></th>        <th></th>    </tr>    <tr>        <th>收集器</th>        <th>收集对象和算法</th>        <th>收集器类型</th>    </tr>    <tr>        <th>Serial</th>        <th>新生代，复制算法</th>        <th>单线程</th>    </tr>    <tr>        <th>ParNew</th>        <th>新生代，复制算法</th>        <th>并行的多线程收集器</th>    </tr>    <tr>        <th>Parallel Scavenge</th>        <th>新生代，复制算法</th>               <th>并行的多线程收集器</th>    </tr>    <tr>        <th>老年代</th>        <th></th>        <th></th>    </tr>    <tr>        <th>Serial Old</th>        <th>老年代，标记整理算法</th>        <th>单线程</th>    </tr>    <tr>        <th>Parallel Old</th>        <th>老年代，标记整理算法</th>        <th>并行的多线程收集器</th>    </tr>    <tr>        <th>CMS</th>        <th>老年代，标记整理算法</th>               <th>并行的多线程收集器</th>    </tr>    <tr>        <th>G1</th>        <th>跨新生代和老年代；标记整理 + 化整为零</th>               <th>并行与并发收集器</th>    </tr></table><p>并行：垃圾收集的多线程的同时进行。<br>并发：垃圾收集的多线程和应用的多线程同时进行。</p><p><img src="http://img.jschen.cn/JVM/GC/SingleThreadWorkflow.png" alt="简单的垃圾回收器工作示意图-单线程"></p><p>简单的解释一下：<br>此时有多个用户线程正在使用，此时要进行垃圾回收，那么就会开启一条GC线程（并且暂停所有的用户线程），新生代回收完之后用户线程继续运行，然后老年代回收的时候也要开启一条GC线程（也会暂停所有的用户线程），回收完后用户线程继续运行。</p><p><img src="http://img.jschen.cn/JVM/GC/MultiThreadWorkflow.png" alt="简单的垃圾回收器工作示意图-多线程"></p><p>多线程与上面单线程的区别就在于它可以开启多条GC线程去回收。<br>新生代的Serial、ParNew、Parallel Scavenge，老年代的Serial Old、Parallel Old都是属于简单的垃圾回收器</p><h2 id="1-Serial-和-Serial-Old"><a href="#1-Serial-和-Serial-Old" class="headerlink" title="1.Serial 和 Serial Old"></a>1.Serial 和 Serial Old</h2><p>最古老的，单线程，独占式，成熟，适合单 CPU 服务器<br>-XX:+UseSerialGC 新生代和老年代都用串行收集器<br>-XX:+UseParNewGC 新生代使用 ParNew，老年代使用 Serial Old<br>-XX:+UseParallelGC 新生代使用 ParallerGC，老年代使用 Serial Old</p><h2 id="2-ParNew"><a href="#2-ParNew" class="headerlink" title="2.ParNew"></a>2.ParNew</h2><p>和 Serial 基本没区别，唯一的区别：多线程，多 CPU 的，停顿时间比 Serial 少<br>-XX:+UseParNewGC 新生代使用 ParNew，老年代使用 Serial Old<br>除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><h2 id="3-Parallel-Scavenge-ParallerGC-和-Parallel-Old"><a href="#3-Parallel-Scavenge-ParallerGC-和-Parallel-Old" class="headerlink" title="3.Parallel Scavenge(ParallerGC) 和 Parallel Old"></a>3.Parallel Scavenge(ParallerGC) 和 Parallel Old</h2><p>关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。<br>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。<br>吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)<br>垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间</p><h2 id="4-Concurrent-Mark-Sweep-（CMS）"><a href="#4-Concurrent-Mark-Sweep-（CMS）" class="headerlink" title="4.Concurrent Mark Sweep （CMS）"></a>4.Concurrent Mark Sweep （CMS）</h2><p>这一个收集器是以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</p><!-- -XX:+UseConcMarkSweepGC ，一般新生代使用 ParNew，老年代的用 CMS --><p>从名字（包含“Mark Sweep”）上就可以看出，CMS 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些， 垃圾回收过程整个过程分为 4 个步骤，包括：</p><ol><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW -Stop the world）。</li><li>并发标记：从 GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li><li>并发清除：不需要停顿。</li></ol><p><img src="http://img.jschen.cn/JVM/GC/CMSCollection.png" alt=""></p><p>优点：由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p>缺点：</p><ol><li>CPU 资源敏感：因为并发阶段多线程占据 CPU 资源，如果 CPU 资源不足，效率会明显降低。</li><li>浮动垃圾：由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为“浮动垃圾”。<br>而且由于浮动垃圾的存在，就必须预留出一部分内存，也就意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。<br>在 1.6 的版本中老年代空间使用率阈值(92%)，如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>会产生空间碎片：标记 - 清除算法会导致产生不连续的空间碎片</li></ol><h2 id="5-G1-垃圾回收器"><a href="#5-G1-垃圾回收器" class="headerlink" title="5.G1 垃圾回收器"></a>5.G1 垃圾回收器</h2><p>从jdk1.7开始就有G1，但是都不推荐使用，直到jdk1.9版本，才推荐使用G1<br>G1 中重要的参数：-XX:+UseG1GC 使用 G1 垃圾回收器<br>内部布局改变：G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。<br><img src="http://img.jschen.cn/JVM/GC/G1.png" alt="G1内存布局"><br>如上图，将内存空间等分，每一个视为一个整体，存放着eden区、survivor区、old区、以及humongous区（大对象），假设内存区域为8G，等分为100个，那么一个区域就有8M，然后每个区域的布局都和图中一样。</p><p>算法：标记—整理 （humongous） 和复制回收算法(survivor)。</p><p>GC 模式</p><ul><li>Young GC：选定所有年轻代里的 Region。通过控制年轻代的 region 个数，即年轻代内存大小，来控制 young GC 的时间开销。（复制回收算法）</li><li>Mixed GC：选定所有年轻代里的 Region，外加根据全局并发标志（global concurrent marking）统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内尽可能选择收益高的老年代 Region。<br>Mixed GC 不是 full GC，它只能回收部分老年代的 Region。如果 mixed GC 实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行 Mixed GC，就会使用 serial old GC（full GC）来收集整个 GC heap。</li></ul><p>全局并发标记（global concurrent marking）</p><ol><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确的可以的 Region 中创建对象，此阶段需要停顿线程(STW)，但耗时很短。</li><li>并发标记：从 GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起</li><li>并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。<br><img src="http://img.jschen.cn/JVM/GC/G1Collection.png" alt=""></li></ol><p>特点</p><ul><li>空间整合：不会产生内存碎片<br>算法：标记—整理 （humongous） 和复制回收算法(survivor)。 </li><li>可预测的停顿：<br>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li></ul><!-- G1 GC 主要的参数参数 含义-XX:G1HeapRegionSize=n 设置 Region 大小，并非最终值-XX:MaxGCPauseMillis 设置 G1 收集过程目标时间，默认值 200ms，不是硬性条件-XX:G1NewSizePercent 新生代最小值，默认值 5%-XX:G1MaxNewSizePercent 新生代最大值，默认值 60%-XX:ParallelGCThreads STW 期间，并行 GC 线程数-XX:ConcGCThreads=n 并发标记阶段，并行执行的线程数-XX:InitiatingHeapOccupancyPercent 设置触发标记周期的 Java 堆占用率阈值。默认值是 45%。这里的 java 堆占比指的是non_young_capacity_bytes，包括 old+humongous垃圾回收器的重要参数（使用-XX:）参数 描述UseSerialGC 虚拟机运行在 Client 模式下的默认值，打开此开关后，使用 Serial+Serial Old 的收集器组合进行内存回收UseParNewGC 打开此开关后，使用 ParNew + Serial Old 的收集器组合进行内存回收UseConcMarkSweepGC 打开此开关后，使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器将作为 CMS 收集器出现 Concurrent Mode Failure 失败后的后备收集器使用UseParallelGC 虚拟机运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old(PS MarkSweep) 的收集器组合进行内存回收UseParallelOldGC 打开此开关后，使用 Parallel Scavenge + Parallel Old 的收集器组合进行内存回收SurvivorRatio 新生代中 Eden 区域与 Survivor 区域的容量比值，默认为 8，代表 Eden : Survivor = 8 : 1PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配MaxTenuringThreshold 晋升到老年代的对象年龄，每个对象在坚持过一次 Minor GC 之后，年龄就增加 1，当超过这个参数值时就进入老年代UseAdaptiveSizePolicy 动态调整 Java 堆中各个区域的大小以及进入老年代的年龄HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个 Eden 和 Survivor 区的所有对象都存活的极端情况ParallelGCThreads 设置并行 GC 时进行内存回收的线程数GCTimeRatio GC 时间占总时间的比率，默认值为 99，即允许 1% 的 GC 时间，仅在使用 Parallel Scavenge 收集器生效MaxGCPauseMillis 设置 GC 的最大停顿时间，仅在使用 Parallel Scavenge 收集器时生效CMSInitiatingOccupancyFraction 设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集，默认值为 68%，仅在使用 CMS 收集器时生效UseCMSCompactAtFullCollection 设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用 CMS 收集器时生效CMSFullGCsBeforeCompaction 设置 CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用 CMS 收集器时生效 --><p>Stop The World 现象<br>GC 收集器和我们 GC 调优的目标就是尽可能的减少 STW 的时间和次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为JVM基础知识的第三篇文章。本文将主要学习垃圾回收算法和垃圾回收器&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JVM相关" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="JVM" scheme="http://jschen.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机中的对象</title>
    <link href="http://jschen.cn/posts/2f70e593/"/>
    <id>http://jschen.cn/posts/2f70e593/</id>
    <published>2020-06-16T15:29:00.000Z</published>
    <updated>2020-07-01T02:01:39.528Z</updated>
    
    <content type="html"><![CDATA[<p>本文为本系列第二篇文章，本文将继续学习JVM基础知识，主要分析对象在虚拟机中如何创建与分配</p><a id="more"></a><h1 id="一、虚拟机中的对象"><a href="#一、虚拟机中的对象" class="headerlink" title="一、虚拟机中的对象"></a>一、虚拟机中的对象</h1><h2 id="1-检查加载"><a href="#1-检查加载" class="headerlink" title="1.检查加载"></a>1.检查加载</h2><p>先执行相应的类加载过程。如果没有，则进行类加载</p><h2 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2.分配内存"></a>2.分配内存</h2><p>根据方法区的信息來确定分配多少内存空间大小给这个类。<br>而分配内存又有两种方式。一种是指针碰撞，另一种是空闲列表</p><p><strong>指针碰撞 (java 堆内存空间规整的情况下使用)</strong></p><p>虚拟机为新生对象分配分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p><p>如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</p><p><img src="http://img.jschen.cn/JVM/Object/PointMove.png" alt="指针碰撞示意图"></p><p><strong>空闲列表 (java 堆空间不规整的情况下使用)</strong></p><p>如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</p><p><img src="http://img.jschen.cn/JVM/Object/FreeList.png" alt="空闲列表示意图"></p><p>至于选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，比如有些就会整理碎片。 因此这里我们只去了解分配方式有哪些即可，不去深入研究。</p><p><strong>并发安全</strong></p><p>在划分可用空间时，还需要考虑一个问题，那就是在虚拟机中创建对象是非常频繁的行为，即使是仅仅修改一个指针所指向<br>的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。</p><p>因此这里需要对安全性进行考虑，解决这个问题有两种方案：<br>一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS（check and act） 配上失败重试的方式保证更新操作的原子性（CAS将在并发的文章中解释）；<br>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用。<br>TLAB 的目的是在为新对象分配内存空间时，让每个 Java 应用线程能在使用自己专属的分配指针来分配空间（Eden 区，默认 Eden 的 1%），减少同步开销，不过这只局限于小对象，对于大对象还是需要使用CAS解决安全问题。<br>TLAB 只是让每个线程有<strong>私有的分配指针</strong>，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。<br>当一个 TLAB 用满（分配指针 top 撞上分配极限 end 了），就新申请一个 TLAB。<br><img src="http://img.jschen.cn/JVM/Object/TLAB.png" alt="分配缓冲示意图"></p><h2 id="3-内存空间初始化"><a href="#3-内存空间初始化" class="headerlink" title="3.内存空间初始化"></a>3.内存空间初始化</h2><p>（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如 int 值为 0，boolean 值为 false 等等)。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h2 id="4-设置"><a href="#4-设置" class="headerlink" title="4.设置"></a>4.设置</h2><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC分代年龄等信息。这些信息存放在对象的对象头之中。</p><h2 id="5-对象初始化"><a href="#5-对象初始化" class="headerlink" title="5.对象初始化"></a>5.对象初始化</h2><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h1 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h1><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头包括两部分信息：<br>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。<br>另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。对象正好是 9 字节的整数，所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全，如1字节就填充7字节。</p><h1 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h1><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。<br>当我们执行<code>Object o = new Object();</code>时<br>Object o 会反映到Java栈的本地变量表中，作为reference类型数据<br>new Object()会反映到Java堆中，作为存储了Object类型所有实例的结构化内存，这块内存不固定，且还要能查到此对象类型数据，使用的方法有句柄池和直接指针</p><p><strong>句柄池</strong><br>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 </p><p><strong>直接指针</strong><br>如果使用直接指针访问， reference 中存储的直接就是对象地址。</p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。<br>对 Sun HotSpot 而言，它是使用直接指针访问方式进行对象访问的。</p><h1 id="四、堆内存分配策略"><a href="#四、堆内存分配策略" class="headerlink" title="四、堆内存分配策略"></a>四、堆内存分配策略</h1><p>堆内存中有新生代和老年代，新生代中又有Eden 区，Survivor(from)区，Survivor(to)区</p><p><img src="http://img.jschen.cn/JVM/Object/HeapMemorydtl.png" alt="堆内存"></p><h2 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1.对象优先在Eden分配"></a>1.对象优先在Eden分配</h2><p>我们首先得知道Eden 区，Survivor(from)区，Survivor(to)区的区别：<br>设置 Survivor(from)区 是为了减少送到老年代的对象，而设置两个 Survivor 区是为了解决碎片化的问题（复制回收算法）</p><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间分配时，虚拟机将发起一次 Minor GC。（GC之后会单独列出来）</p><p><strong>注意：新生代初始时就有大小，会占用eden区部分空间。</strong></p><h2 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2.大对象直接进入老年代"></a>2.大对象直接进入老年代</h2><p>当某个对象在eden区放不下，那么它就会直接进入到老年代。<br>假设eden区此时只剩下5M的大小，但是此时有一个6M的对象进来，发起GC之后空间还是不够，那么它会直接进入到老年代中</p><p>最典型的大对象是那种很长的字符串以及数组。<br>这样做的目的：1. 避免大量内存复制；2. 避免提前进行垃圾回收，明明内存有空间进行分配。</p><h2 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3.长期存活的对象将进入老年代"></a>3.长期存活的对象将进入老年代</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1，对象在 Survivor区中每熬过一次 Minor GC，年龄就增加 1，当它的年龄增加到一定程度(默认为 15)时，就会被晋升到老年代中。（可以理解为闯关游戏，打过了15关你就有排名（进入老年代），中途挂了（被回收了）就结束）</p><h2 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4.动态对象年龄判定"></a>4.动态对象年龄判定</h2><p>如果在 Survivor 空间中相同年龄所有对象大小的综合大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。如下图<br><img src="http://img.jschen.cn/JVM/Object/AgeDetermine.png" alt="动态年龄判断"><br>更详细理解可以看这个连接(<a href="https://blog.csdn.net/dingshuo168/article/details/100126324">https://blog.csdn.net/dingshuo168/article/details/100126324</a>)</p><h2 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5.空间分配担保"></a>5.空间分配担保</h2><p>空间分配担保是为了避免过于频繁执行Full GC。</p><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，</p><ul><li>如果大于，那么可以确保此次 Minor GC 是安全的。</li><li>如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。<br>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。<br>如果HandlePromotionFailure=false，那此时也要改为进行一次 Full GC</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为本系列第二篇文章，本文将继续学习JVM基础知识，主要分析对象在虚拟机中如何创建与分配&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JVM相关" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="JVM" scheme="http://jschen.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM整体结构</title>
    <link href="http://jschen.cn/posts/1f66094b/"/>
    <id>http://jschen.cn/posts/1f66094b/</id>
    <published>2020-06-11T06:55:00.000Z</published>
    <updated>2020-07-01T06:34:23.360Z</updated>
    
    <content type="html"><![CDATA[<p>本系列主要开始学习JVM基础知识，作为本系列第一篇文章，本文主要涉及JVM的整体结构，如线程私有区域和共享区域，每个区域又有什么东西</p><a id="more"></a><h1 id="JAVA-SE-体系架构"><a href="#JAVA-SE-体系架构" class="headerlink" title="JAVA SE 体系架构"></a>JAVA SE 体系架构</h1><p>JDK：开发工具包，包含了JRE和一些编译器、调试程序等工具<br>JRE：Java SE运行环境，提供了库、Java虚拟机和其他组件来运行通过Java语言编写的程序<br>JVM：Java虚拟机，负责 JavaSE 平台的硬件和操作系统无关性、编译执行代码（字节码）和平台安全性</p><p><img src="http://img.jschen.cn/JVM/Base/Base.png" alt="JVM体系架构图"></p><p>从上图可以看出，JVM 在最底层，JRE包含了JVM以及一些库（如JDBC、Math等），JDK则包含了JRE，并且还有一些工具（如javac、javap等）</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！（它是一个抽象概念。内部实现依赖寄存器、高速缓存、主内存）</p><p>线程私有:程序计数器、虚拟机栈、本地方法栈<br>线程共享：堆、方法区<br>可以理解为线程共享的是数据，而线程私有的是操作的指令<br><img src="http://img.jschen.cn/JVM/Base/RuntimeDataArea.png" alt="JVM运行时数据区"></p><h3 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a>线程私有区域</h3><p>一、 程序计数器</p><p>程序计数器：程序执行的计数器，指向当前线程正在执行的字节码指令的地址（行号）</p><p>如果线程正在执行的是一个Java方法，则指明当前线程执行的字节码行数；<br>如果正在执行的是Native方法，这个计数器就会为空（Undefined）</p><p>思考：为什么需要程序计数器？</p><p>因为Java是多线程的，意味着会不停切换线程，而为了保证多线程的情况下程序能正常运行，就需要程序计数器来记录当前线程执行到了哪一行，也就是当线程能继续执行的时候，告诉线程我上一次执行到了哪个位置。所以每个线程都会有自己的程序计数器，互不影响，所以这也是JVM中唯一不会发生OOM的地方。</p><p>二、 栈</p><p>我们需要知道栈是一种先入后出(FILO)的数据结构，且出口和入口都只有一个。栈的大小缺省为 1M，可用参数 –Xss 调整大小，例如-Xss256k</p><p>对应的异常：</p><ul><li>线程请求的栈深度大于虚拟机所允许的深度：StackOverflowError（栈溢出）</li><li>JVM 动态扩展时无法申请到足够的内存时：OutOfMemoryError（所谓的OOM，内存溢出）</li></ul><p>思考：JVM为什么使用栈？<br>使用栈，是为了更好的方法调用方法。</p><p>1.虚拟机栈：存储当前线程运行方法所需的数据，指令、返回地址</p><p>线程在运行时，在执行每个方法的时候都会打包成一个栈帧，栈帧中存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放到栈里面去。每个时刻正在执行的当前的方法肯定是处于虚拟机栈顶的栈帧,入栈就代表方法执行，出栈就代表方法结束。入栈采用的是压栈的方式，出栈采用弹栈的方式。</p><p>以下面简单的类为例子，A()调用B()、B()又调用了C()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFilo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A();  <span class="comment">//A()-&gt;B()-&gt;C()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A开始"</span>);</span><br><span class="line">        B();<span class="comment">//调用B方法</span></span><br><span class="line">        System.out.println(<span class="string">"A结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B开始"</span>);</span><br><span class="line">        B();<span class="comment">//调用B方法</span></span><br><span class="line">        System.out.println(<span class="string">"B结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"C结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先划分出一块内存区域，然后A入栈，存放在栈顶，然后B入栈，把A往下压，此时B处于栈顶，然后C入栈，把B和A往下压，此时C处于栈顶，当C执行完，C出栈，B往上弹，A也一样往上弹，但此时B在栈顶，当B执行完，B出栈，A往上弹，回到栈顶，最终A执行完，A出栈。</p><p>虚拟机栈中有哪些东西呢？</p><ul><li>局部变量表：顾名思义就是局部变量的表，用于存放我们的局部变量的，存放八大数据类型和object对象的引用地址。</li><li>操作数据栈：存放我们方法执行的操作数，方法刚开始时操作数栈为空，如果有个局部变量，比如int i ；i = i + 1，那么操作数栈就会对这个 i 操作，进行运算后得到 i+1 的结果，然后覆盖原本的 i。</li><li>动态连接：Java 语言特性多态（需要类加载、运行时才能确定具体的方法）</li><li>返回地址：正常返回（调用程序计数器中的地址作为返回）</li></ul><p>2.本地方法栈：保存native方法的信息。</p><p>上面说过线程在运行时，在执行每个方法的时候都会打包成一个栈帧。但是如果是native方法，那么不会去创建栈帧，JVM只会简单地动态链接并直接调用native方法。不同虚拟机不同的实现，与用C/C++相关。</p><h3 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h3><p>一、方法区/永久代</p><p>用于存储已经被虚拟机加载的类信息，常量(“abc”,”123”等)，静态变量(static 变量)等数据，可用以下参数调整：<br>jdk1.7 及以前，叫做永久代，jdk1.8以后改名为元空间<br>jdk1.7 及以前：-XX:PermSize；-XX:MaxPermSize；<br>jdk1.8 以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize<br>jdk1.8 以后大小就只受本机总内存的限制<br>如：-XX:MaxMetaspaceSize=3M</p><p>二、堆</p><p>堆涉及到内存分配以及垃圾回收，几乎所有的对象都是在堆中分配，并且也是垃圾回收的主要区域<br>-Xms：堆的最小值；<br>-Xmx：堆的最大值；<br>-Xmn：新生代的大小；<br>-XX:NewSize；新生代最小值；<br>-XX:MaxNewSize：新生代最大值；<br>例如- Xmx256m</p><p>三、运行时常量池 </p><p>1.符号引用（一个概念）</p><p>假设一个 Customer 类，被编译成class文件时，Customer类有引用另一个类（Tools）。<br>在编译customer类时，它不并知道tools类的实际地址，因此只能使用符号引用来代替。<br>当类装载器装载 Customer 类时，此时可以通过虚拟机获取 Tool 类的实际内存地址，因此便可以既将符号 org.simple.Tool 替换为 Tool 类的实际内存地址，及直接引用地址。<br>即在编译时用符号引用来代替引用类，在加载时再通过虚拟机获取该引用类的实际地址. 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。</p><p>2.字面量</p><p>声明为final的常量、八种基本类型如int a = 1中的1，string b = “abc” 中的abc<br>在JDK1.6，运行时常量池在方法区中<br>在JDK1.7以及之后版本，运行时常量池在堆中</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存不是虚拟机运行数据区的一部分，也不是虚拟机规范中定义的内存区域。</p><p>如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；<br>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常；<br>优点：避免了在Java 堆和Native 堆中来回复制数据，能够提高效率</p><h1 id="深入辨析堆和栈"><a href="#深入辨析堆和栈" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char 等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；而堆内存用来存储 Java 中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p><h2 id="线程独享还是共享"><a href="#线程独享还是共享" class="headerlink" title="线程独享还是共享"></a>线程独享还是共享</h2><p>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。<br>堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p><h2 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h2><p>栈的内存要远远小于堆内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列主要开始学习JVM基础知识，作为本系列第一篇文章，本文主要涉及JVM的整体结构，如线程私有区域和共享区域，每个区域又有什么东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JVM相关" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="JVM" scheme="http://jschen.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="http://jschen.cn/posts/b9f6280b/"/>
    <id>http://jschen.cn/posts/b9f6280b/</id>
    <published>2020-05-26T02:18:00.000Z</published>
    <updated>2020-06-25T14:54:29.842Z</updated>
    
    <content type="html"><![CDATA[<p>本文将学习解线程基础知识，线程之间的共享与协作</p><a id="more"></a><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><br /><h3 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程"></a>什么是进程和线程</h3><p>以下为百度百科摘抄的部分简介</p><blockquote><p><a href="https://baike.baidu.com/item/进程">进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础</a></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/线程">线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</a></p></blockquote><p>进程是暂时的，是程序在数据集上的一次执行，当你运行一个程序,也就跟着启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。</p><p>进程又分为系统进程和用户进程，可以由用户控制关闭的是用户进程，系统进程不会受到用户干预，如内存分配，进程切换等</p><p>线程是进程的一个实体，是 CPU 调度和分派的基本单位。它不拥有系统资源，但是他会拥有派生它的进程的资源（如程序计数器，寄存器，栈等），可以和同一进程下的其他线程共享线程拥有的全部资源。<br><br /></p><h3 id="CPU核心数和线程数的关系"><a href="#CPU核心数和线程数的关系" class="headerlink" title="CPU核心数和线程数的关系"></a>CPU核心数和线程数的关系</h3><p>多核心，简单理解就是一个芯片多个处理器，每个处理器能并行地执行不同进程<br><br /><br>多线程：让一个处理器上的多个线程同步执行并共享处理器的执行资源。<br>通过增加核心数来增加线程数，正常情况下 核心数:线程数 = 1:1，也就是说四核=4线程，现在的CPU有很多已经支持超线程，如i7，i9，使核心数:线程数 = 1:2<br><br /></p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>原则上一个 CPU 只能分配给一个进程,以便运行这个进程。要让它能同时运行多个线程,就必须使用到并发技术。实现并发技术很复杂，最容易理解的是“<a href="https://baike.baidu.com/item/时间片轮转调度算法">时间片轮转调度算法</a>”</p><p>并行：应用能够同时执行不同的任务，比如一条四车道公路能允许四辆车同时并排行走<br>并发：应用能够交替执行不同的任务。如单核心的情况下执行多线程，处理器在我们察觉不到的情况下高速切换两个线程，达到“同时执行”的效果</p><h3 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h3><ol><li>充分利用CPU资源。现在CPU基本都是多核，如果使用单线程那就只用到了CPU一个核心，那就浪费了。</li><li>加快响应时间。比如迅雷可以同时下载多个文件</li><li>可以使我们的代码模块化，异步化，简单化。如电商系统，用户下订单之后发送短信和邮件，就可以做成单独的模块，交给其他线程执行。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>线程安全性</li><li>死锁</li><li>线程过多导致宕机<br /></li></ol><h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h2><br /><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ol><li>X extends Thread，然后X.start()</li><li>implements Runnable，然后交给Thread运行。如new Thread(Runnable).start()</li></ol><p>Thread才是java中对线程的唯一抽象。runnable只是对任务的抽象，并不参与实际执行。</p><h3 id="中止"><a href="#中止" class="headerlink" title="中止"></a>中止</h3><ol><li>自然中止，run方法执行完成或者抛异常导致线程提前结束</li><li>使用suspend()、resume()和stop()，但是这些方法都不建议使用，具体原因可查看文档：<a href="https://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html">《Why Are Thread.stop, Thread.suspend,Thread.resume and Runtime.runFinalizersOnExit Deprecated?》</a></li></ol><h3 id="中断-（安全的中止）"><a href="#中断-（安全的中止）" class="headerlink" title="中断 （安全的中止）"></a>中断 （安全的中止）</h3><p><strong>* 处于死锁状态的线程无法被中断 *</strong></p><p>使用interrupt()通知线程需要中断，设置标志符为true（这里只是通知，并没有强制停止）</p><ol><li>可以通过isinterrupt()判断是否被中断</li><li>或者通过调用静态方法Thread.interrupt()来判断是否中断（这一方法会将标志符设置为false）</li></ol><p>如果一个线程处于阻塞状态（线程调用sleep()、join()、wait()），此时调用方法检查到中断标志符为true时，那么此时会抛出异常，并将标志符清除，重新设置为false</p><p>不建议自定义标志符来中断线程运行（自定义一个变量，在想线程停止时设置为true，然后判断变量为true时停止线程）</p><p>因为在run方法中有阻塞调用时，自定义标识符会检测不到，只有等阻塞调用返回了才能检查到<br><br /></p><h2 id="三、对Java中的线程再多点认识"><a href="#三、对Java中的线程再多点认识" class="headerlink" title="三、对Java中的线程再多点认识"></a>三、对Java中的线程再多点认识</h2><p><img src="http://img.jschen.cn/thread/thread_overview.png" alt="线程概述图"><br><br /></p><h3 id="深入理解run-和start"><a href="#深入理解run-和start" class="headerlink" title="深入理解run()和start()"></a>深入理解run()和start()</h3><p>我们通过执行new Thread，new出一个thread实例，但是此时还没有和系统中真正的线程挂钩，只有执行了start()方法，才算是真正的启动了线程。</p><p>start()方法能让一个线程进入就绪状态等待分配CPU，等分配到了CPU 那么才能实现run方法，如果start方法重复调用则会抛异常。<br /><br>run()方法是业务逻辑实现的地方，和成员方法一样，可多次调用。</p><h3 id="其他的线程方法"><a href="#其他的线程方法" class="headerlink" title="其他的线程方法"></a>其他的线程方法</h3><p>yield()方法：让出当前CPU使用权，但不释放锁资源。</p><p>注意：</p><ol><li>有可能执行yield()方法的线程执行完了，有可能不拥有锁资源了，也可能拥有的锁资源别的线程不需要，所以这里是不会释放锁资源的。</li><li>虽然让出了CPU使用权，但是这个CPU给谁使用是由“<a href="https://baike.baidu.com/item/时间片轮转调度算法">时间片轮转调度算法</a>”决定的，所以CPU又分配给了执行yield()方法的线程</li></ol><p>wait()/notify()/notifyAll():之后再列出来</p><p>join()方法：将两个交替执行的线程变成顺序执行，如B线程调用了A线程的join()方法，那么就要等到A线程执行完了，才能执行B线程。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10，在线程构建的时候可以通过 setPriority(int)方法来修改优先级，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。<br>设置线程优先级时，针对频繁阻塞（休眠或者 I/O 操作）的线程需要设置较高优先级，而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。<code>在不同的 JVM 以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</code></p><h3 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程 Daemon"></a>守护线程 Daemon</h3><p>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调<br>度以及支持性工作。可以通过调用 Thread.setDaemon(true)将线程设置为 Daemon 线程，当主进程结束后守护进程也会跟着结束（我们一般用不上，比如垃圾回收线程就是 Daemon 线程。）</p><p>Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行(因为分配给线程的时间由时间片轮转调度决定)。在构建 Daemon 线程时，不能依靠 finally 块中的内容来确保执行关闭或清理资源的逻辑。（非守护进程的finally会被正常执行）</p><h3 id="线程间的共享和协作"><a href="#线程间的共享和协作" class="headerlink" title="线程间的共享和协作"></a>线程间的共享和协作</h3><p>synchronize内置锁(针对对象)</p><p>Java 支持多个线程同时访问一个对象或者对象的成员变量。<br /><br>关键字synchronized 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><p>对象锁和类锁：</p><p>对象锁是用于对象实例方法，或者一个对象实例上的；<br />类锁是用于类的静态方法或者一个类的 class 对象上的。</p><p>我们知道，类的对象实例可以有很多个，但是每个类只有一个 class 对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。<br>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的 class 对象。类锁和对象锁之间也是互不干扰的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将学习解线程基础知识，线程之间的共享与协作&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://jschen.cn/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="线程" scheme="http://jschen.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="http://jschen.cn/posts/f876582f/"/>
    <id>http://jschen.cn/posts/f876582f/</id>
    <published>2020-05-04T15:30:00.000Z</published>
    <updated>2020-07-09T01:27:53.322Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客 , 感谢你从茫茫人海中发现了这里!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到我的博客 , 感谢你从茫茫人海中发现了这里!&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://jschen.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
